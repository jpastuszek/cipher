#!/usr/bin/env ruby

require 'cli'
require 'haddock'
require 'logger'
require_relative '../lib/cipher'

settings = CLI.new do
	stdin :data
	description "Encrypts or decrypts data on stdin.\nExample usage: cat LICENSE.txt | be bin/cipher -p test --in-block-size 8 | be bin/cipher -d -p test --in-block-size 8"
	option :cipher,
		short: :c,
		description: 'select cipher to use',
		default: 'AES'
	option :key_length,
		short: :k,
		description: 'cipher key length in bits (rounded to multiple of 8)',
		cast: Integer,
		default_label: 'longest preset'
	option :mode,
		short: :m,
		description: 'cipher streaming mode',
		default: 'prefer CBC'
	option :password,
		short: :p,
		description: 'encryption or decryption password',
		default_label: 'auto generated'
	option :initialization_vector,
		short: :i,
		description: 'initialization vector for CBC, CFB, OFB and CTR modes',
		default_label: 'random'
	option :session_key,
		short: :s,
		description: 'session key',
		default_label: 'random'
	option :in_block_size,
		short: :b,
		description: 'input read block size',
		default: 1024*256,
		cast: Integer
	switch :list,
		short: :L,
		description: 'list all cipher, mode and key length combinations'
	switch :list_ciphers,
		short: :C,
		description: 'list ciphers'
	switch :list_key_lengths,
		short: :K,
		description: 'list available key lenghts for selected cipher'
	switch :list_modes,
		short: :M,
		description: 'list available modes for given cipher and key length'
	switch :decrypt,
		short: :d,
		description: 'decrypt data'
	switch :no_padding,
		short: :P,
		description: 'do not add/expect padding at the end of encrypted stream'
end.parse! do |settings|
	cipher_selector = CipherSelector.new

	if settings.list
		cipher_selector.flat_list do |*list|
			STDERR.puts "%s %s %s" % list
		end
		exit
	end

	if settings.list_ciphers
		STDERR.puts cipher_selector.ciphers.sort.join ' '
		exit
	end

	mode_selctor = cipher_selector.cipher(settings.cipher)

	if settings.list_modes
		STDERR.puts mode_selctor.modes.map(&:to_s).sort.join ' '
		exit
	end

	key_length_selector = 
	if settings.mode =~ /prefer (.+)/
		mode_selctor.preferred_mode($1)
	else
		mode_selctor.mode(settings.mode)
	end

	if settings.list_key_lengths
		STDERR.puts key_length_selector.key_lengths.sort{ |a, b|
			next 1 if not a.is_a? Numeric
			next -1 if not b.is_a? Numeric
			a <=> b
		}.join(' ')
		exit
	end

	cipher_selector =
	if settings.key_length
		key_length_selector.key_length(settings.key_length.to_i)
	else
		key_length_selector.longest_key(256)
	end

	key_bytes_length = (cipher_selector.key_length.to_f / 8).ceil

	if settings.initialization_vector
		settings.initialization_vector.length == key_bytes_length or fail "initialization vector should be #{key_bytes_length} characters long"
	end

	if settings.session_key
		settings.session_key.length == key_bytes_length or fail "session key should be #{key_bytes_length} characters long"
	end

	settings.cipher_selector = cipher_selector
end

log = Logger.new(STDERR)
log.formatter = proc do |severity, datetime, progname, msg|
	  "#{settings.decrypt ? 'D:' : 'E:'} #{msg}\n"
end

unless settings.password
	settings.password = Haddock::Password.generate
	log.info "Using password: #{settings.password}"
end

options = {}
options[:log] = log
options[:initialization_vector] = settings.initialization_vector if settings.initialization_vector
options[:session_key] = settings.session_key if settings.session_key
options[:padding] = ! settings.no_padding

unless settings.decrypt
	IOEncrypter.new(settings.stdin, STDOUT, settings.cipher_selector, settings.password, options)
else
	IODecrypter.new(settings.stdin, STDOUT, settings.password, options)
end

