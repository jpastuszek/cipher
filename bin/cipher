#!/usr/bin/env ruby

require 'openssl'
require 'base64'
require 'cli'
require 'haddock'
require 'sdl4r'
require 'logger'
require_relative '../lib/cipher'

class String
	def base64_multiline
		Base64.encode64(self)
	end

	def base64
		Base64.strict_encode64(self)
	end

	def unbase64
		Base64.strict_decode64(self)
	end
end

settings = CLI.new do
	stdin :data
	option :cipher,
		short: :c,
		description: 'select cipher to use',
		default: 'AES'
	option :key_length,
		short: :k,
		description: 'cipher key length in bits (rounded to multiple of 8)',
		cast: Integer,
		default_label: 'longest preset'
	option :mode,
		short: :m,
		description: 'cipher streaming mode',
		default: 'prefer CBC'
	option :password,
		short: :p,
		description: 'encryption or decryption password',
		default_label: 'auto generated'
	option :initialization_vector,
		short: :i,
		description: 'initialization vector for CBC, CFB, OFB and CTR modes',
		default_label: 'random'
	option :password_digest,
		short: :P,
		description: 'digest to use to hash password for cipher key',
		default: 'SHA256'
	option :in_block_size,
		description: 'input read block size',
		default: 1024*256,
		cast: Integer
	switch :list,
		short: :L,
		description: 'list all cipher, mode and key combinations'
	switch :list_ciphers,
		short: :C,
		description: 'list ciphers'
	switch :list_key_lengths,
		short: :K,
		description: 'list available key lenghts for selected cipher'
	switch :list_modes,
		short: :M,
		description: 'list available modes for given cipher and key length'
	switch :decrypt,
		short: :d,
		description: 'decrypt data'
end.parse! do |settings|
	cipher_selector = CipherSelector.new

	if settings.list
		cipher_selector.flat_list do |*list|
			STDERR.puts "%s %s %s" % list
		end
		exit
	end

	if settings.list_ciphers
		STDERR.puts cipher_selector.ciphers.sort.join ' '
		exit
	end

	mode_selctor = cipher_selector.cipher(settings.cipher)

	if settings.list_modes
		STDERR.puts mode_selctor.modes.map(&:to_s).sort.join ' '
		exit
	end

	key_length_selector = 
	if settings.mode =~ /prefer (.+)/
		mode_selctor.preferred_mode($1)
	else
		mode_selctor.mode(settings.mode)
	end

	if settings.list_key_lengths
		STDERR.puts key_length_selector.key_lengths.sort{ |a, b|
			next 1 if not a.is_a? Numeric
			next -1 if not b.is_a? Numeric
			a <=> b
		}.join(' ')
		exit
	end

	settings.openssl_cipher =
	if settings.key_length
		key_length_selector.key_length(settings.key_length.to_i)
	else
		key_length_selector.longest_key(256)
	end
end

log = Logger.new(STDERR)
log.formatter = proc do |severity, datetime, progname, msg|
	  "#{settings.decrypt ? 'D:' : 'E:'} #{msg}\n"
end

class Key < String
	def initialize(password, password_digest)
		super OpenSSL::Digest.new(password_digest).update(password).digest
	end
end

class Encrypter
	def initialize(cipher_name, key, options = {})
		@header = {}
		@log = options[:log] || Logger.new(STDERR)

		@log.info "Using cipher: #{cipher_name}"
		@cipher = OpenSSL::Cipher::Cipher.new(cipher_name)
		@header[:cipher] = cipher_name

		@cipher.encrypt

		if options[:key_length]
			rounded_key_length = options[:key_length] / 8 * 8
			@log.info "Using key length: #{rounded_key_length}"
			@cipher.key_len = rounded_key_length / 8
			@header[:key_length] = rounded_key_length
		end

		@log.debug "Using key: #{key.base64}"
		@cipher.key = key

		initialization_vector = if options[:initialization_vector]
			options[:initialization_vector]
		else
			@cipher.random_iv
		end

		unless initialization_vector.empty?
			@cipher.iv = initialization_vector 
			@header[:initialization_vector] = initialization_vector.base64
			@log.debug "Using initialization vector: #{initialization_vector.base64}"
		end
	end

	def each(&sink)
		@sink = sink
		@sink.call(SDL4R.dump(@header) + "\n")
		self
	end

	def <<(data)
		@sink.call @cipher.update(data)
	end

	def encrypt
		yield self
		fail 'no sink' unless @sink
		@sink.call @cipher.final
	end
end

class Decrypter
	def initialize(key, options = {})
		@log = options[:log] || Logger.new(STDERR)
		@key = key
	end

	def <<(data)
		unless @header
			header, data = *data.split("\n\n", 2)
			@header = SDL4R.load(header)

			@log.info "Using decipher: #{@header.cipher}"
			@cipher = OpenSSL::Cipher::Cipher.new(@header.cipher)

			@cipher.decrypt

			if @header.key_length
				@log.info "Using key length: #{@header.key_length}"
				@cipher.key_len = @header.key_length / 8
			end

			@log.debug "Using key: #{@key.base64}"
			@cipher.key = @key

			if @header.initialization_vector
				@log.debug "Using initialization vector: #{@header.initialization_vector}"
				@cipher.iv = @header.initialization_vector.unbase64
			end
		end

		fail 'no sink' unless @sink
		fail 'bad header' unless @cipher

		@sink.call @cipher.update(data)
	end

	def each(&sink)
		@sink = sink
	end

	def decrypt
		yield self
		@sink.call @cipher.final
	end
end

unless settings.password
	settings.password = Haddock::Password.generate
	log.info "Using password: #{settings.password}"
end

options = {}
options[:log] = log
options[:key_length] = settings.openssl_cipher.key_length if settings.openssl_cipher.need_key_length_set?
options[:initialization_vector] = settings.initialization_vector.ljust(16) if settings.initialization_vector

key = Key.new(settings.password, settings.password_digest)

unless settings.decrypt
	e = Encrypter.new(settings.openssl_cipher.openssl_cipher_name, key, options)

	e.each do |encrypted_data_chunk|
		print encrypted_data_chunk
	end

	e.encrypt do |e|
		while data = settings.stdin.read(settings.in_block_size)
			e << data
		end
	end
else
	d = Decrypter.new(key, options)

	d.each do |decrypted_data_chunk|
		print decrypted_data_chunk
	end

	d.decrypt do |d|
		while data = settings.stdin.read(settings.in_block_size)
			d << data
		end
	end
end

